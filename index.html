<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cyberpunk Neon Chamber â€“ Smooth Camera</title>
<style>
body { margin:0; overflow:hidden; background: radial-gradient(#02020a, #000000);}
canvas { display:block; touch-action:none; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let icons=[], raycaster=new THREE.Raycaster(), mouse=new THREE.Vector2();
let activeIcon=null, currentTier=0, haloIcon=null;

// Camera targets
let cameraPosTarget=new THREE.Vector3(0,20,150);
let cameraLookTarget=new THREE.Vector3(0,20,0);

// Audio
const clickAudio=new Audio("https://www.soundjay.com/button/sounds/button-10.mp3");
const softTone=new Audio("https://www.soundjay.com/button/sounds/button-16.mp3");

// Particle bursts
let bursts=[];
function createBurst(position){
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const count = 20;
    for(let i=0;i<count;i++){ positions.push(position.x, position.y, position.z); }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
    const material = new THREE.PointsMaterial({color:0xffff33, size:5, transparent:true, opacity:0.8});
    const points = new THREE.Points(geometry, material);
    points.userData.life=0;
    points.userData.vels=[];
    for(let i=0;i<count;i++){
        const angle = Math.random()*2*Math.PI;
        const speed = Math.random()*0.3+0.1;
        points.userData.vels.push(new THREE.Vector3(Math.cos(angle)*speed, Math.random()*0.2, Math.sin(angle)*speed));
    }
    scene.add(points);
    bursts.push(points);
}

// Mock chart
function createMockChart(type){
    const size=128;
    const canvas=document.createElement('canvas');
    canvas.width=size; canvas.height=size;
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,size,size);
    ctx.fillStyle="rgba(20,20,40,0.8)";
    ctx.beginPath(); ctx.arc(size/2,size/2,size/2-5,0,2*Math.PI); ctx.fill();
    ctx.strokeStyle="#33ccff"; ctx.lineWidth=6;
    if(type==="circle"){ ctx.beginPath(); ctx.arc(size/2,size/2,size/2-10,0,Math.random()*2*Math.PI); ctx.stroke(); }
    else if(type==="line"){ ctx.beginPath(); ctx.moveTo(10,size-10); for(let i=0;i<10;i++){ const x=i*(size-20)/9+10; const y=size-10-Math.random()*(size-20); ctx.lineTo(x,y);} ctx.stroke();}
    else if(type==="disk"){ let start=0; for(let i=0;i<3;i++){ const value=Math.random()*0.3+0.2; ctx.beginPath(); ctx.moveTo(size/2,size/2); ctx.arc(size/2,size/2,size/2-10,start,start+2*Math.PI*value); ctx.closePath(); ctx.stroke(); start+=2*Math.PI*value;}}
    return new THREE.CanvasTexture(canvas);
}

// Initialize scene
function init(){
    scene=new THREE.Scene();
    camera=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,2000);
    renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0x3311aa,1.2));
    const pointLight=new THREE.PointLight(0x33ccff,2.5,1000);
    pointLight.position.set(0,0,400);
    scene.add(pointLight);

    const cubeWidth=200, cubeHeight=100, cubeDepth=300, cubeSeparation=150;

    for(let levelIdx=0; levelIdx<2; levelIdx++){
        const levelY=levelIdx*cubeSeparation;

        const cubeGeo=new THREE.BoxGeometry(cubeWidth,cubeHeight,cubeDepth);
        const edges=new THREE.EdgesGeometry(cubeGeo);
        const edge1=new THREE.LineSegments(edges,new THREE.LineBasicMaterial({color:0x00ffff,linewidth:2}));
        const edge2=new THREE.LineSegments(edges,new THREE.LineBasicMaterial({color:0xff33ff,linewidth:1}));
        edge1.position.y=edge2.position.y=levelY;
        scene.add(edge1,edge2);

        const backIcons=[ new THREE.Vector3(-40,10,-cubeDepth/2+1), new THREE.Vector3(0,0,-cubeDepth/2+1), new THREE.Vector3(40,-10,-cubeDepth/2+1) ];
        const sideIcons=[ new THREE.Vector3(-cubeWidth/2+1,30,-100), new THREE.Vector3(-cubeWidth/2+1,-20,-50), new THREE.Vector3(cubeWidth/2-1,10,-80), new THREE.Vector3(cubeWidth/2-1,-15,-120) ];
        const allIcons=backIcons.concat(sideIcons);
        const neonColors=[0x00ffff,0xff33ff,0x33ff33,0xffff33];
        const chartTypes=["circle","line","disk"];

        allIcons.forEach((pos,i)=>{
            const color=neonColors[i%neonColors.length];
            const iconGeo=new THREE.PlaneGeometry(35,35);
            const iconMat=new THREE.MeshStandardMaterial({
                map:createMockChart(chartTypes[i%chartTypes.length]),
                transparent:true, opacity:0.85, metalness:0.8, roughness:0.05,
                emissive:color, emissiveIntensity:1.2
            });
            const icon=new THREE.Mesh(iconGeo,iconMat);
            icon.position.copy(pos); icon.position.y+=levelY;
            icon.userData.isSideWall=(pos.x<-cubeWidth/4 || pos.x>cubeWidth/4);
            if(icon.userData.isSideWall) icon.rotation.y = (pos.x<0)? Math.PI/2 : -Math.PI/2;
            icon.userData.defaultRot = icon.rotation.clone();
            icon.userData.tier = levelIdx;
            icon.userData.isZoomed=false;
            icon.userData.tiltTarget=undefined;
            icon.userData.pulseOffset=Math.random()*10;
            scene.add(icon);
            icons.push(icon);
        });

        if(levelIdx===0){
            const haloGeo=new THREE.RingGeometry(12,16,32);
            const haloMat=new THREE.MeshStandardMaterial({color:0xffff00, emissive:0xffff00, transparent:true, opacity:0.8, side:THREE.DoubleSide});
            haloIcon = new THREE.Mesh(haloGeo,haloMat);
            haloIcon.position.set(0, levelY + cubeHeight/2, -cubeDepth/2 + 5);
            haloIcon.userData.isUpDown=true;
            scene.add(haloIcon);
            icons.push(haloIcon);
        }
    }

    // Input
    let lastTouch=null, touching=false;
    function startTouch(x,y){ touching=true; lastTouch={x,y}; }
    function moveTouch(x,y){
        if(!touching) return;
        const dx=(x-lastTouch.x)/window.innerWidth*0.2;
        const dy=(y-lastTouch.y)/window.innerHeight*0.2;
        lastTouch={x,y};
    }

    function handlePointer(x,y){
        mouse.x=(x/window.innerWidth)*2-1;
        mouse.y=-(y/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse,camera);
        const intersects=raycaster.intersectObjects(icons);
        if(intersects.length>0){
            const obj=intersects[0].object;
            clickAudio.currentTime=0; clickAudio.play();

            if(obj.userData.isUpDown){
                moveToTier(obj.position.y > cameraPosTarget.y ? 1 : 0);
            } else if(obj.userData.tier===currentTier){
                if(activeIcon===obj){ // toggle off
                    activeIcon.userData.isZoomed=false;
                    activeIcon=null;
                    cameraPosTarget.set(0,20,150);
                    cameraLookTarget.set(0,20,0);
                    if(obj.userData.isSideWall) obj.userData.tiltTarget=0;
                } else { // toggle on
                    activeIcon=obj;
                    obj.userData.isZoomed=true;
                    softTone.currentTime=0; softTone.play();
                    createBurst(obj.position);

                    // Camera moves to cube center
                    cameraPosTarget.set(0, obj.position.y, 0);
                    cameraLookTarget.copy(obj.position);

                    // Side-wall tilt
                    if(obj.userData.isSideWall) obj.userData.tiltTarget=-0.35;
                }
            }
        } else { // clicked empty space
            if(activeIcon){
                if(activeIcon.userData.isSideWall) activeIcon.userData.tiltTarget=0;
                activeIcon.userData.isZoomed=false;
                activeIcon=null;
                cameraPosTarget.set(0,20,150);
                cameraLookTarget.set(0,20,0);
            }
        }
    }

    window.addEventListener("mousedown", e=>{ handlePointer(e.clientX,e.clientY); startTouch(e.clientX,e.clientY); });
    window.addEventListener("mousemove", e=>{ moveTouch(e.clientX,e.clientY); });
    window.addEventListener("mouseup", ()=>{ touching=false; });
    window.addEventListener("touchstart", e=>{ handlePointer(e.touches[0].clientX,e.touches[0].clientY); startTouch(e.touches[0].clientX,e.touches[0].clientY); }, {passive:false});
    window.addEventListener("touchmove", e=>{ moveTouch(e.touches[0].clientX,e.touches[0].clientY); }, {passive:false});
    window.addEventListener("touchend", ()=>{ touching=false; });
    window.addEventListener("resize", ()=>{
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });
}

function moveToTier(tier){
    currentTier=tier;
    cameraPosTarget.y = tier*150 + 20;
    cameraLookTarget.y = tier*150 + 20;
}

function animate(){
    requestAnimationFrame(animate);
    const time=performance.now()*0.002;

    // --- Smooth camera movement ---
    const moveDir = cameraPosTarget.clone().sub(camera.position);
    const dist = moveDir.length();
    const step = 0.8; // speed
    if(dist > step){
        moveDir.normalize().multiplyScalar(step);
        camera.position.add(moveDir);
    } else {
        camera.position.copy(cameraPosTarget);
    }

    // Smooth lookAt
    const currentLook = camera.getWorldDirection(new THREE.Vector3()).normalize();
    const desiredLook = cameraLookTarget.clone().sub(camera.position).normalize();
    const smoothLook = currentLook.lerp(desiredLook, 0.05).normalize();
    camera.lookAt(camera.position.clone().add(smoothLook));

    // Icons
    icons.forEach(icon=>{
        if(icon.userData.isUpDown){
            const pulse=1+0.05*Math.sin(time*5);
            icon.scale.set(pulse,pulse,pulse);
        } else if(icon.userData.tier===currentTier){
            const pulse=1+0.05*Math.sin(time + (icon.userData.pulseOffset||0));
            let scaleTarget = activeIcon===icon ? 1.5 : pulse;
            icon.scale.x = icon.scale.y = icon.scale.z = THREE.MathUtils.lerp(icon.scale.x, scaleTarget,0.05);

            if(icon.userData.isSideWall){
                let targetRot = icon.userData.tiltTarget!==undefined ? icon.userData.tiltTarget : icon.userData.defaultRot.x;
                icon.rotation.x = THREE.MathUtils.lerp(icon.rotation.x, targetRot,0.05);
            }
        } else {
            icon.material.opacity = 0.3;
        }
    });

    // Particle bursts
    bursts.forEach((b,i)=>{
        b.userData.life+=1;
        const positions = b.geometry.attributes.position.array;
        for(let j=0;j<positions.length;j+=3){
            positions[j]+=b.userData.vels[j/3].x;
            positions[j+1]+=b.userData.vels[j/3].y;
            positions[j+2]+=b.userData.vels[j/3].z;
        }
        b.geometry.attributes.position.needsUpdate=true;
        b.material.opacity *= 0.92;
        if(b.userData.life>30){ scene.remove(b); bursts.splice(i,1); }
    });

    renderer.render(scene,camera);
}

init();
animate();
</script>
</body>
</html>
